package headless

import (
	"context"
	"fmt"

	"github.com/entrhq/forge/pkg/agent/git"
	"github.com/entrhq/forge/pkg/llm"
	"github.com/entrhq/forge/pkg/types"
)

const (
	defaultBaseBranch = "main"
)

// createPullRequest creates a GitHub pull request for the committed changes
func (e *Executor) createPullRequest(ctx context.Context) error {
	// Get current branch (head)
	head, err := e.gitManager.GetCurrentBranch(ctx)
	if err != nil {
		return fmt.Errorf("failed to get current branch: %w", err)
	}

	// Detect or use configured base branch
	base := e.config.Git.PRBase
	if base == "" {
		detectedBase, detectErr := git.DetectBaseBranch(e.config.WorkspaceDir)
		if detectErr != nil {
			e.logger.Warningf("! Could not detect base branch, using '%s': %v", defaultBaseBranch, detectErr)
			base = defaultBaseBranch
		} else {
			base = detectedBase
			e.logger.Debugf("Detected base branch: %s", base)
		}
	}

	// Generate PR title and description if not provided
	title := e.config.Git.PRTitle
	body := e.config.Git.PRBody

	if title == "" || body == "" {
		prContent, genErr := e.generatePRContent(ctx, base, head)
		if genErr != nil {
			e.logger.Warningf("! Failed to generate PR content, using defaults: %v", genErr)
			if title == "" {
				title = fmt.Sprintf("chore: automated changes in %s", head)
			}
			if body == "" {
				body = fmt.Sprintf("Automated changes generated by Forge.\n\nTask: %s", e.config.Task)
			}
		} else {
			if title == "" {
				title = prContent.Title
			}
			if body == "" {
				body = prContent.Description
			}
		}
	}

	e.logger.Debugf("Creating PR: %s -> %s", head, base)
	e.logger.Debugf("PR Title: %s", title)

	// Push branch before creating PR
	e.logger.Infof("↑ Pushing to origin/%s...", head)
	if pushErr := e.gitManager.Push(ctx); pushErr != nil {
		return fmt.Errorf("failed to push branch: %w", pushErr)
	}

	// Create PR using existing git.CreatePR function
	prURL, err := git.CreatePR(e.config.WorkspaceDir, title, body, base, head)
	if err != nil {
		return fmt.Errorf("failed to create pull request: %w", err)
	}

	e.logger.Successf("⇄ Created pull request: %s", prURL)

	// Store PR URL in summary for artifact generation
	e.summary.PRURL = prURL

	return nil
}

// generatePRContent generates PR title and description using LLM
func (e *Executor) generatePRContent(ctx context.Context, base, head string) (*git.PRContent, error) {
	if e.llmProvider == nil {
		return nil, fmt.Errorf("LLM provider not available for PR content generation")
	}

	// Get commits since base branch
	commits, err := git.GetCommitsSinceBase(e.config.WorkspaceDir, base, head)
	if err != nil {
		return nil, fmt.Errorf("failed to get commits: %w", err)
	}

	// Get diff summary
	diffSummary, err := git.GetDiffSummary(e.config.WorkspaceDir, base, head)
	if err != nil {
		return nil, fmt.Errorf("failed to get diff: %w", err)
	}

	// Create LLM client wrapper
	llmClient := &llmClientWrapper{provider: e.llmProvider}

	// Use existing PRGenerator
	generator := git.NewPRGenerator(llmClient)
	return generator.Generate(ctx, commits, diffSummary, base, head, "")
}

// llmClientWrapper wraps llm.Provider to implement git.LLMClient interface
type llmClientWrapper struct {
	provider llm.Provider
}

func (w *llmClientWrapper) Generate(ctx context.Context, prompt string) (string, error) {
	// Convert prompt to message format expected by llm.Provider
	messages := []*types.Message{
		{
			Role:    "user",
			Content: prompt,
		},
	}

	// Use Complete method to get full response
	response, err := w.provider.Complete(ctx, messages)
	if err != nil {
		return "", err
	}

	return response.Content, nil
}
